{"version":3,"sources":["dataMuseProxy.ts","types.ts","graphStyle.ts","colors.ts","util.ts","algorithm.ts","InputForm.tsx","WordDetails.tsx","acronym/acronymQuery.ts","acronym/AcronymHelper.tsx","cluehelper/ideas.tsx","cluehelper/ClueHelper.tsx","cluehelper/util.tsx","Home.tsx","Routes.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["QUERY_TYPE","DataMuseQuery","usp","appendToUsp","key","val","append","getQueryUrl","toString","execute","a","url","fetch","response","console","log","ok","Error","status","json","parameterize","queryType","str","this","URLSearchParams","DataMuseProxy","query","instance","getInstance","ExpansionType","MyNode","word","type","id","toElementDef","data","MyEdge","source","target","colorGetter","index","colors","getNextColor","result","length","j","x","i","Math","floor","random","shuffle","nodeTypesToBackgroundColor","ORIGINAL","SYNONYM","RHYME","CY_STYLE","selector","style","ele","mapVal","undefined","styleGraph","cy","nodes","forEach","node","indegree","color","incomingRhymeEdges","incomers","connectedNodes","cytoscape","use","dagre","expandGraph","inputWords","expansionConfig","expansionResult","createdNodes","createdEdges","expansionWordPromises","inputWord","evaluatedExpansionWordPromise","then","expansionWordJson","slice","maxQueryResults","expansionWordData","expansionWord","expansionNode","expansionEdge","push","Promise","all","makeGraph","originalWords","divId","allNodes","allEdges","originalWord","originalWordNode","synonymExpansionConfig","SYNONYMS_WITH","synonymExpansionResult","rhymeExpansionConfig","RHYMES_WITH","rhymeExpansionInputWords","map","rhymeExpansionResult","allNodesAndEdges","concat","allElementDefs","nodeOrEdge","container","document","getElementById","elements","layout","name","InputForm","props","input","React","createRef","handleSubmit","e","preventDefault","current","JSON","stringify","value","unprocessedWords","words","split","trim","replace","onSubmitInput","render","onSubmit","defaultValue","ref","state","PureComponent","WordDetails","componentDidMount","Object","entries","allQueryResults","Map","queryPromises","enumKey","enumVal","MAX","queryPromise","ogWord","queryResult","set","setState","Array","from","queryDescription","queryResultString","queryEntry","join","getAcronymQueryResults","letters","relatedTo","limit","letterResultPromises","letter","getOne","letterResults","RELATED_TO","SPELLED_LIKE","relatedWordsThatStartWithQueryLetter","queryResultItem","queryLetter","AcronymHelper","lettersInput","relatedToInput","limitInput","unprocessedLetters","warn","limitStr","match","Number","acronymQueryResults","renderQueryResults","allRows","acronymQueryResult","tableDataFromResult","autoFocus","wordplays","ideate","link","href","anagram","phraseSearch","createDatamuseClueIdea","queryParameterizer","nonLimitedUrl","resultWords","item","resultWordEls","resultWord","moreLink","prefix","dmq","suffix","frequentFollowers","LEFT_CONTEXT","RIGHT_CONTEXT","FREQUENT_FOLLOWERS","frequentPredecessors","FREQUENT_PREDECESSORS","hoponyms","HOPONYMS","hypernyms","HYPERNYMS","CLUE_IDEAS","ClueHelper","addError","newError","prevState","errors","delimiter","tableInputObject","idea","renderableIdea","copy","assign","tableInput","renderIdeas","rows","isArray","headers","keys","headerEls","header","rowEls","row","rowEl","td","makeTable","className","placeholder","Home","ogWords","buildingGraph","graphData","wordDetailsElements","Routes","basename","path","App","Boolean","window","location","hostname","ReactDOM","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"2OASYA,E,2IAAAA,K,uBAAAA,E,wBAAAA,E,sBAAAA,E,mCAAAA,E,gBAAAA,E,iBAAAA,E,kBAAAA,E,0BAAAA,E,oBAAAA,E,yBAAAA,E,kBAAAA,E,UAAAA,E,UAAAA,E,kBAAAA,E,mBAAAA,E,6BAAAA,E,gCAAAA,E,mBAAAA,E,qBAAAA,M,KA2BL,IAAMC,EAGX,aAAe,IAAD,gCAFdC,SAEc,OAINC,YAAc,SAACC,EAAaC,GAElC,OADA,EAAKH,IAAII,OAAOF,EAAKC,GACd,GANK,KASdE,YAAc,WACZ,MAAM,GAAN,OAhDiB,iCAgDjB,YAA0B,EAAKL,IAAIM,aAVvB,KAcdC,QAdc,sBAcJ,gCAAAC,EAAA,6DACFC,EAAM,EAAKJ,cADT,SAEyBK,MAAMD,GAF/B,UAEFE,EAFE,OAGRC,QAAQC,IAAR,2CAAgDJ,IAC3CE,EAASG,GAJN,sBAKA,IAAIC,MAAJ,6CAAgDJ,EAASK,SALzD,uBAOWL,EAASM,OAPpB,cAOFA,EAPE,yBAUDA,GAVC,4CAdI,KA2BdC,aAAe,SAACC,EAAuBC,GACrC,OAAO,EAAKnB,YAAYkB,EAAWC,IA3BnCC,KAAKrB,IAAM,IAAIsB,iBA+BNC,EAGX,aAAuB,yBAQvBC,MAAQ,WACN,OAAO,IAAIzB,IAZFwB,EACIE,SAA0B,IAAIF,EADlCA,EAOJG,YAAc,WACnB,OAAOH,EAAcE,U,IC3EbE,E,kBAAAA,K,oBAAAA,E,kBAAAA,E,kBAAAA,E,eAAAA,M,KAOL,I,EAAMC,EAIX,WAAYC,EAAcC,GAAsB,IAAD,gCAH/CC,QAG+C,OAF/CD,UAE+C,OAK/CE,aAAe,WACb,MAAO,CACLC,KAAM,IANRZ,KAAKU,GAAKF,EACVR,KAAKS,KAAOA,GAUHI,EAKX,WAAYC,EAAgBC,EAAgBN,GAAsB,IAAD,gCAJjEC,QAIiE,OAHjEI,YAGiE,OAFjEC,YAEiE,OADjEN,UACiE,OAOjEE,aAAe,WACb,MAAO,CACLC,KAAM,IARRZ,KAAKU,GAAL,UAAaI,EAAb,aAAwBC,GACxBf,KAAKc,OAASA,EACdd,KAAKe,OAASA,EACdf,KAAKS,KAAOA,GC/BVO,EAAc,CAClBC,MAAO,EACPC,OCNgC,CAQlC,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WDlNEC,aAAc,WACZ,IAAMC,EAASpB,KAAKkB,OAAOlB,KAAKiB,OAEhC,OADAjB,KAAKiB,OAASjB,KAAKiB,MAAQ,GAAKjB,KAAKkB,OAAOG,OACrCD,KEPJ,SAAiBjC,GACtB,IAAIm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","file":"static/js/main.7ff32edd.chunk.js","sourcesContent":["\nconst API_BASE_URL = 'https://api.datamuse.com/words';\n\nexport interface DataMuseQueryResultItem {\n  score: number;\n  word: string;\n  tags: string[];\n}\n\nexport enum QUERY_TYPE {\n  HOMOPHONE_OF = 'rel_hom',\n  SYNONYMS_WITH = 'rel_syn',\n  RHYMES_WITH = 'rel_rhy',\n  STRONGLY_ASSOCIATED_WITH = 'rel_trg',\n  RELATED_TO = 'ml',\n  SOUNDS_LIKE = 'sl',\n  SPELLED_LIKE = 'sp',\n  IS_DESCRIBED_BY = 'rel_jjb',\n  DESCRIBES = 'rel_jja',\n  SORTED_BY_TOPIC = 'topics',\n  // TODO this is a duplicate with leftContext\n  COMES_BEFORE = 'lc',\n  MAX = 'max',\n  SUG = 'sug',\n  // Use to find words that come after the query word in a sentence.\n  LEFT_CONTEXT = 'lc',\n  RIGHT_CONTEXT = 'rc',\n  FREQUENT_FOLLOWERS = 'rel_bga',\n  FREQUENT_PREDECESSORS = 'rel_bgb',\n  HOPONYMS = 'rel_gen',\n  HYPERNYMS = 'rel_spc',\n};\n\nexport type DataMuseQueryResult = DataMuseQueryResultItem[];\n\n// TODO(ak): replace spaces with plusses. url-encode in general.\nexport class DataMuseQuery {\n  usp: URLSearchParams;\n\n  constructor() {\n    this.usp = new URLSearchParams();\n  }\n\n  private appendToUsp = (key: string, val: string): DataMuseQuery => {\n    this.usp.append(key, val);\n    return this;\n  }\n\n  getQueryUrl = (): string => {\n    return `${API_BASE_URL}?${this.usp.toString()}`;\n\n  }\n\n  execute = async (): Promise<DataMuseQueryResult> => {\n    const url = this.getQueryUrl();\n    const response: Response = await fetch(url);\n    console.log(`Executing dataMuse query to URL: ${url}`);\n    if (!response.ok) {\n      throw new Error(`fetch dataMuse failed with status: ${response.status}`)\n    }\n    const json = await response.json();\n    \n    // TODO(ak): return as type?\n    return json;\n  }\n\n  parameterize = (queryType: QUERY_TYPE, str: string): DataMuseQuery => {\n    return this.appendToUsp(queryType, str);\n  }\n}\n\nexport class DataMuseProxy {\n  private static instance: DataMuseProxy = new DataMuseProxy();\n\n  private constructor() {\n\n  }\n\n  static getInstance = () => {\n    return DataMuseProxy.instance;\n  }\n\n  query = () => {\n    return new DataMuseQuery();\n  }\n}","import { QUERY_TYPE } from \"./dataMuseProxy\";\nimport { ElementDefinition } from \"cytoscape\";\n\n\nexport enum ExpansionType {\n  ORIGINAL = \"ORIGINAL\",\n  SYNONYM = \"SYNONYM\",\n  RELATED = \"RELATED\",\n  RHYME = \"RHYME\",\n}\n\nexport class MyNode {\n  id: string;\n  type: ExpansionType;\n\n  constructor(word: string, type: ExpansionType) {\n    this.id = word;\n    this.type = type;\n  }\n\n  toElementDef = (): ElementDefinition => {\n    return {\n      data: this,\n    };\n  }\n}\n\nexport class MyEdge {\n  id: string;\n  source: string;\n  target: string;\n  type: ExpansionType;\n  constructor(source: string, target: string, type: ExpansionType) {\n    this.id = `${source}->${target}`\n    this.source = source;\n    this.target = target;\n    this.type = type;\n  }\n  \n  toElementDef = (): ElementDefinition => {\n    return {\n      data: this,\n    };\n  }\n}\n\nexport interface ExpansionConfig {\n  queryType: QUERY_TYPE;\n  type: ExpansionType;\n  maxQueryResults: number;\n}\n\nexport interface ExpansionResult {\n  createdNodes: MyNode[];\n  createdEdges: MyEdge[];\n}","import { NodeSingular } from \"cytoscape\";\nimport { RHYME_GROUP_COLORS } from \"./colors\";\nimport { shuffle } from \"./util\";\nimport { ExpansionType } from \"./types\";\n\nconst colorGetter = {\n  index: 0,\n  colors: RHYME_GROUP_COLORS,\n  getNextColor: function() {\n    const result = this.colors[this.index];\n    this.index = (this.index + 1) % this.colors.length;\n    return result;\n  }\n}\n\nshuffle(colorGetter.colors);\n\nconst nodeTypesToBackgroundColor: { [key: string]: any } = {\n  [ExpansionType.ORIGINAL]: '#111',\n  [ExpansionType.SYNONYM]: '#666',\n  [ExpansionType.RHYME]: '#999' \n};\n\nexport const CY_STYLE = [\n  {\n    selector: 'node',\n    style: {\n      'background-color': function( ele: any ){\n        const mapVal = nodeTypesToBackgroundColor[ele.data('type')];\n        if (mapVal !== undefined) {\n          return mapVal;\n        }\n        return '#666';\n      },\n      'label': 'data(id)'\n    }\n  },\n\n  {\n    selector: 'edge',\n    style: {\n      'width': 3,\n      'line-color': '#ccc',\n      'target-arrow-color': '#ccc',\n      'target-arrow-shape': 'triangle',\n      'curve-style': 'bezier'\n    }\n  }\n];\n\nexport const styleGraph = (cy: cytoscape.Core) => {\n  // color connected synonyms\n  cy.nodes().forEach((node: NodeSingular) => {\n    if (node.indegree(false) >= 2) {\n      const color = colorGetter.getNextColor();\n      // incomers or neighbors works\n      // const sharedSynonyms = node.incomers();\n      const incomingRhymeEdges = node.incomers(`edge[type = \"${ExpansionType.RHYME}\"]`);\n      incomingRhymeEdges.style('lineColor', color);\n      const incomingRhymeNodes = incomingRhymeEdges.connectedNodes('node');\n      incomingRhymeNodes.style('background-color', color);\n\n\n      // Dumb shit I tried since I forgot I was selecting rhymes.\n\n      // node.parents().forEach((p) => {p.style('background-color', 'gold')});\n      // node.ancestors().forEach((p) => {p.style('background-color', 'gold')});\n      // node.ancestors().style('background-color', 'gold');\n      // node.connectedEdges().style('background-color', 'gold');\n      // node.style('background-color', 'gold');\n\n\n      // node.edges().style('background-color', color);\n      // node.connectedEdges().animate({style: {lineColor: color} });\n      // node.incomers().animate({style: {lineColor: color} });\n      // node.incomers().style('lineColor', color);\n      // node.predecessors().style('lineColor', color);\n      // node.edgesWith('*').style('lineColor', color);\n      // cy.nodes().edgesWith(node).style('lineColor', color);\n      // All nodes edges to?\n\n    }\n  });\n}","\nexport const RHYME_GROUP_COLORS = [\n// comment out the grays\n// '#000000',\n// '#333333',\n// '#666666',\n// '#999999',\n// '#CCCCCC',\n// '#FFFFFF',\n'#996666',\n'#663333',\n'#CC9999',\n'#993333',\n'#CC6666',\n'#CC3333',\n'#330000',\n'#660000',\n'#990000',\n'#CC0000',\n'#FF0000',\n'#FF3333',\n'#FF6666',\n'#FF9999',\n'#FFCCCC',\n'#FF3300',\n'#CC3300',\n'#FF6633',\n'#CC6633',\n'#993300',\n'#FF9966',\n'#FF6600',\n'#996633',\n'#CC9966',\n'#663300',\n'#CC6600',\n'#FF9933',\n'#FFCC99',\n'#FF9900',\n'#CC9933',\n'#996600',\n'#FFCC66',\n'#CC9900',\n'#FFCC33',\n'#FFCC00',\n'#999966',\n'#666633',\n'#CCCC99',\n'#999933',\n'#CCCC66',\n'#CCCC33',\n'#333300',\n'#666600',\n'#999900',\n'#CCCC00',\n'#FFFF00',\n'#FFFF33',\n'#FFFF66',\n'#FFFF99',\n'#FFFFCC',\n'#CCFF00',\n'#99CC00',\n'#CCFF33',\n'#99CC33',\n'#669900',\n'#CCFF66',\n'#99FF00',\n'#669933',\n'#99CC66',\n'#336600',\n'#66CC00',\n'#99FF33',\n'#CCFF99',\n'#66FF00',\n'#66CC33',\n'#339900',\n'#99FF66',\n'#33CC00',\n'#66FF33',\n'#33FF00',\n'#669966',\n'#336633',\n'#99CC99',\n'#339933',\n'#66CC66',\n'#33CC33',\n'#003300',\n'#006600',\n'#009900',\n'#00CC00',\n'#00FF00',\n'#33FF33',\n'#66FF66',\n'#99FF99',\n'#CCFFCC',\n'#00FF33',\n'#00CC33',\n'#33FF66',\n'#33CC66',\n'#009933',\n'#66FF99',\n'#00FF66',\n'#339966',\n'#66CC99',\n'#006633',\n'#00CC66',\n'#33FF99',\n'#99FFCC',\n'#00FF99',\n'#33CC99',\n'#009966',\n'#66FFCC',\n'#00CC99',\n'#33FFCC',\n'#00FFCC',\n'#669999',\n'#336666',\n'#99CCCC',\n'#339999',\n'#66CCCC',\n'#33CCCC',\n'#003333',\n'#006666',\n'#009999',\n'#00CCCC',\n'#00FFFF',\n'#33FFFF',\n'#66FFFF',\n'#99FFFF',\n'#CCFFFF',\n'#00CCFF',\n'#0099CC',\n'#33CCFF',\n'#3399CC',\n'#006699',\n'#66CCFF',\n'#0099FF',\n'#336699',\n'#6699CC',\n'#003366',\n'#0066CC',\n'#3399FF',\n'#99CCFF',\n'#0066FF',\n'#3366CC',\n'#003399',\n'#6699FF',\n'#0033CC',\n'#3366FF',\n'#0033FF',\n'#666699',\n'#333366',\n'#9999CC',\n'#333399',\n'#6666CC',\n'#3333CC',\n'#000033',\n'#000066',\n'#000099',\n'#0000CC',\n'#0000FF',\n'#3333FF',\n'#6666FF',\n'#9999FF',\n'#CCCCFF',\n'#3300FF',\n'#3300CC',\n'#6633FF',\n'#6633CC',\n'#330099',\n'#9966FF',\n'#6600FF',\n'#663399',\n'#9966CC',\n'#330066',\n'#6600CC',\n'#9933FF',\n'#CC99FF',\n'#9900FF',\n'#9933CC',\n'#660099',\n'#CC66FF',\n'#9900CC',\n'#CC33FF',\n'#CC00FF',\n'#996699',\n'#663366',\n'#CC99CC',\n'#993399',\n'#CC66CC',\n'#CC33CC',\n'#330033',\n'#660066',\n'#990099',\n'#CC00CC',\n'#FF00FF',\n'#FF33FF',\n'#FF66FF',\n'#FF99FF',\n'#FFCCFF',\n'#FF00CC',\n'#CC0099',\n'#FF33CC',\n'#CC3399',\n'#990066',\n'#FF66CC',\n'#FF0099',\n'#993366',\n'#CC6699',\n'#660033',\n'#CC0066',\n'#FF3399',\n'#FF99CC',\n'#FF0066',\n'#CC3366',\n'#990033',\n'#FF6699',\n'#CC0033',\n'#FF3366',\n'#FF0033',\n];","/**\n * Shuffles array in place.\n * @param {Array} a items An array containing the items.\n */\nexport function shuffle(a: Array<any>) {\n  var j, x, i;\n  for (i = a.length - 1; i > 0; i--) {\n      j = Math.floor(Math.random() * (i + 1));\n      x = a[i];\n      a[i] = a[j];\n      a[j] = x;\n  }\n  return a;\n}","\n/** Take in a set of initial words, run queries, and produce a graph. */\n\nimport cytoscape, { ElementDefinition } from \"cytoscape\";\n\nimport { DataMuseProxy, DataMuseQueryResult, QUERY_TYPE } from \"./dataMuseProxy\";\nimport { CY_STYLE, styleGraph } from \"./graphStyle\";\nimport { ExpansionType, ExpansionResult, ExpansionConfig, MyNode, MyEdge } from \"./types\";\n\n// Enable dagre layout.\n// @ts-ignore\nimport dagre from 'cytoscape-dagre';\ncytoscape.use( dagre );\n\nconst MAX_RELATED_TO_RESULTS = 50;\nconst MAX_RHYME_RESULTS = 50;\n\n\n// Expands graph with a datamuse query. Returns ids of added nodes.\nconst expandGraph = async (inputWords: string[], expansionConfig: ExpansionConfig): Promise<ExpansionResult> => {\n  const expansionResult: ExpansionResult = {\n    createdNodes: [],\n    createdEdges: [],\n  };\n\n  const expansionWordPromises: Promise<any>[] = [];\n\n  inputWords.forEach((inputWord: string) => {\n    const expansionWordDataPromise: Promise<any> = DataMuseProxy\n      .getInstance().query()\n      .parameterize(expansionConfig.queryType, inputWord).execute();\n    const evaluatedExpansionWordPromise = expansionWordDataPromise.then((expansionWordJson: DataMuseQueryResult) => {\n      // TODO(ak): slice in query instead of after...\n      expansionWordJson.slice(0, expansionConfig.maxQueryResults).forEach((expansionWordData) => {\n        const expansionWord = expansionWordData.word;\n        const expansionNode: MyNode = new MyNode(expansionWord, expansionConfig.type);\n        const expansionEdge: MyEdge = new MyEdge(inputWord, expansionWord, expansionConfig.type);\n        expansionResult.createdNodes.push(expansionNode);\n        expansionResult.createdEdges.push(expansionEdge);\n      });\n    });\n    expansionWordPromises.push(evaluatedExpansionWordPromise);\n  });\n\n  await Promise.all(expansionWordPromises);\n\n  return expansionResult;\n}\n\nexport const makeGraph = async (originalWords: string[], divId: string) => {\n  \n  const allNodes: MyNode[] = [];\n  const allEdges: MyEdge[] = [];\n\n  // Push OG words as nodes.\n  originalWords.forEach((originalWord: string) => {\n    const originalWordNode = new MyNode(originalWord, ExpansionType.ORIGINAL);\n    allNodes.push(originalWordNode);\n  });\n\n\n  // RelatedTo expansion.\n  // const relatedToExpansionConfig: ExpansionConfig = {\n  //   queryType: QUERY_TYPE.RELATED_TO,\n  //   type: ExpansionType.RELATED,\n  //   maxQueryResults: MAX_RELATED_TO_RESULTS,\n  // };\n  // const relatedToExpansionResult: ExpansionResult = await expandGraph(originalWords, relatedToExpansionConfig);\n  // allNodes.push(...relatedToExpansionResult.createdNodes);\n  // allEdges.push(...relatedToExpansionResult.createdEdges);\n\n  // Synonym expansion.\n  const synonymExpansionConfig: ExpansionConfig = {\n    queryType: QUERY_TYPE.SYNONYMS_WITH,\n    type: ExpansionType.SYNONYM,\n    maxQueryResults: 20,\n  };\n  const synonymExpansionResult: ExpansionResult = await expandGraph(originalWords, synonymExpansionConfig);\n  allNodes.push(...synonymExpansionResult.createdNodes);\n  allEdges.push(...synonymExpansionResult.createdEdges);\n\n  // Rhyme expansion.\n  const rhymeExpansionConfig: ExpansionConfig = {\n    queryType: QUERY_TYPE.RHYMES_WITH,\n    type: ExpansionType.RHYME,\n    maxQueryResults: MAX_RHYME_RESULTS,\n  };\n  const rhymeExpansionInputWords: string[] = allNodes.map((node) => node.id);\n  const rhymeExpansionResult = await expandGraph(rhymeExpansionInputWords, rhymeExpansionConfig);\n  allNodes.push(...rhymeExpansionResult.createdNodes);\n  allEdges.push(...rhymeExpansionResult.createdEdges);\n\n  // Build Graph.\n  const allNodesAndEdges = allNodes.concat(allEdges);\n  const allElementDefs = allNodesAndEdges.map((nodeOrEdge) => nodeOrEdge.toElementDef());\n  const cy = cytoscape({\n    container: document.getElementById('cy'),\n    elements: allElementDefs,\n    style: CY_STYLE,\n    layout: {\n      name: \"dagre\",\n    },\n  });\n\n  // TODO node style ORIGINAL instead of original.\n  styleGraph(cy);\n  return cy.json();\n}\n","import React from 'react';\n\ninterface Props {\n  onSubmitInput: (words: string[]) => any;\n}\n\ninterface State {\n\n}\n\nexport default class InputForm extends React.PureComponent<Props, State> {\n \n  input: React.RefObject<HTMLInputElement> = React.createRef();;\n  \n  constructor(props: Props) {\n    super(props);\n    this.state = {\n\n    };\n  }\n\n  handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    console.log(`submitting with words: ${this.input.current}`);\n    console.log(JSON.stringify(this.input.current?.value));\n\n    const unprocessedWords = this.input.current?.value;\n    if (!unprocessedWords) {\n      return;\n    }\n\n    const words = unprocessedWords.split(',').map((word: string) => {\n      return word.trim().replace(' ', '+')\n    });\n    console.log(`making graph with words ${JSON.stringify(words)}`);\n    // this.makeGraphTest(words);\n    this.props.onSubmitInput(words);\n  }\n\n  // Other useful default values: \n  // scarece, equitable\n  // kitten, baseball (has OG word rhyme with synonym)\n  // abortion, hole, condom, recession (lots of results, distill)\n  // job, hobby -> profession, obsession (doesn't work though). Need a wider search and distilled results.\n  render = () => {\n    return (\n        <form onSubmit={this.handleSubmit}>\n          <label>\n            Words:\n            <input\n              defaultValue=\"kitten, baseball\"\n              type=\"text\"\n              ref={this.input} />\n          </label>\n          <input type=\"submit\" value=\"Submit\" />\n        </form>\n    );\n  }\n}\n\n","import React from 'react';\nimport { QUERY_TYPE, DataMuseProxy, DataMuseQueryResult, DataMuseQueryResultItem } from './dataMuseProxy';\n\ninterface Props {\n  ogWord: string;\n}\n\ninterface State {\n  // queryDescription -> results\n  allQueryResults?: Map<string, DataMuseQueryResult>;\n}\n\nconst MAX_WORD_DETAILS_QUERY_RESULTS = 10;\n\n/** Extensive details on a selected word. Use onclick. */\nexport default class WordDetails extends React.PureComponent<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n\n    };\n  }\n\n  componentDidMount = async () => {\n    console.log(QUERY_TYPE);\n    console.log(Object.entries(QUERY_TYPE));\n    const allQueryResults: Map<string, DataMuseQueryResultItem[]> = new Map();\n    const queryPromises: Promise<any>[] = [];\n    Object.entries(QUERY_TYPE).forEach(([enumKey, enumVal]: [string, QUERY_TYPE]) => {\n\n      if (enumVal === QUERY_TYPE.MAX) {\n        // skip MAX\n        return;\n      }\n      const queryPromise = DataMuseProxy.getInstance().query()\n        .parameterize(enumVal, this.props.ogWord)\n        .parameterize(QUERY_TYPE.MAX, MAX_WORD_DETAILS_QUERY_RESULTS.toString())\n        .execute()\n        .then((queryResult: DataMuseQueryResult) => {\n          allQueryResults.set(enumKey, queryResult);\n        });\n      queryPromises.push(queryPromise);\n    });\n    await Promise.all(queryPromises);\n    this.setState({\n      allQueryResults,\n    });\n  }\n\n  render = () => {\n    if (this.state.allQueryResults === undefined) {\n      return (<p>Loading WordDetails for {this.props.ogWord}</p>);\n    }\n\n    return (\n      <div>\n        <h3>Word Details for {this.props.ogWord}</h3>\n      <table>\n        <tbody>\n        {Array.from(this.state.allQueryResults.entries()).map(([queryDescription, queryResult]) => {\n          const queryResultString = queryResult.map((queryEntry) => queryEntry.word).join(', ');\n          return (\n            <tr key={queryDescription}>\n                <td>{queryDescription}</td><td>{queryResultString}</td>\n            </tr>\n          );\n        })}\n        </tbody>\n      </table>\n      </div>\n    );\n  }\n}\n\n","import { DataMuseProxy, QUERY_TYPE, DataMuseQueryResult } from \"../dataMuseProxy\";\n\nexport type AcronymQueryResult = {\n  queryLetter: string;\n  relatedWordsThatStartWithQueryLetter: string[];\n}\n\nexport const getAcronymQueryResults = async (letters: string[], relatedTo: string, limit: number): Promise<AcronymQueryResult[]> => {\n  const letterResultPromises: Promise<AcronymQueryResult>[] = [];\n  letters.forEach((letter) => {\n    letterResultPromises.push(getOne(letter, relatedTo, limit));\n  });\n  const letterResults = await Promise.all(letterResultPromises);\n  return letterResults;\n};\n\nconst getOne = async (letter: string, relatedTo: string, limit: number): Promise<AcronymQueryResult> => {\n  const queryResult: DataMuseQueryResult = await DataMuseProxy.getInstance().query()\n    .parameterize(QUERY_TYPE.RELATED_TO, relatedTo)\n    .parameterize(QUERY_TYPE.SPELLED_LIKE, `${letter}*`)\n    .parameterize(QUERY_TYPE.MAX, limit.toString())\n    .execute();\n  const relatedWordsThatStartWithQueryLetter = queryResult.map((queryResultItem) => {\n    return queryResultItem.word;\n  });\n\n  return {\n    queryLetter: letter,\n    relatedWordsThatStartWithQueryLetter,\n  };\n};","import React from \"react\";\nimport { AcronymQueryResult, getAcronymQueryResults } from \"./acronymQuery\";\nimport './AcronymHelper.css';\n\n\ninterface Props {\n  /** If this component is the \"main\" one and should have its first input autoFocused. */\n  autoFocus?: boolean;\n}\ninterface State {\n  acronymQueryResults?: AcronymQueryResult[],\n}\n\n// TODO\n// another input for related word\n// another input for limit\n// generate a couple combos?\n\nconst DEFAULT_LIMIT = 10;\n\n/** Takes Letters and concepts, helps you create an acronym. */\nexport default class AcronymHelper extends React.PureComponent<Props, State> {\n  lettersInput: React.RefObject<HTMLInputElement> = React.createRef();\n  relatedToInput: React.RefObject<HTMLInputElement> = React.createRef();\n  limitInput: React.RefObject<HTMLInputElement> = React.createRef();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n    };\n  }\n\n  handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n\n    const unprocessedLetters = this.lettersInput.current?.value;\n    if (!unprocessedLetters) {\n      console.warn(`Invalid letters`);\n      return;\n    }\n\n    const letters = unprocessedLetters.split('');\n\n    const relatedTo = this.relatedToInput.current?.value;\n    if (!relatedTo) {\n      console.warn(`Invalid relatedTo`);\n      return;\n    }\n\n    const limitStr = this.limitInput.current?.value;\n    if (!limitStr || !limitStr.match(/^\\d+$/)) {\n      console.warn(`Invalid limit, must be positive int.`);\n    }\n    const limit = Number(limitStr);\n    if (limit < 1 || limit > 100) {\n      console.warn(`Invalid limit, must be in range (1, 100)`);\n    }\n\n    const acronymQueryResults: AcronymQueryResult[] = await getAcronymQueryResults(letters, relatedTo, limit);\n    this.setState({\n      acronymQueryResults,\n    });\n  }\n\n  // TODO table format\n  renderQueryResults = () => {\n    if (!this.state.acronymQueryResults) {\n      return null;\n    }\n\n\n    const allRows = this.state.acronymQueryResults.map((acronymQueryResult, index) => {\n      const tableDataFromResult = acronymQueryResult.relatedWordsThatStartWithQueryLetter.map((word) => {\n        return (<td key={word}>{word}</td>)\n      });\n      return (\n        // TODO remove duplicates to get rid of \"index\" in the key.\n        <tr key={`${acronymQueryResult.queryLetter}-${index}`}><td>{acronymQueryResult.queryLetter}</td>{tableDataFromResult}</tr>\n      );\n    });\n\n    return (\n      <table>\n        <tbody>\n          <tr>\n            <th>Letter</th>\n            <th>Results</th>\n          </tr>\n          {allRows}\n        </tbody>\n      </table>\n    );\n  }\n\n  render = () => {\n    return (\n      <div id=\"AcronymHelper\">\n        <h2>Acronym Helper</h2>\n        <h3>Input</h3>\n        <form onSubmit={this.handleSubmit}>\n          <label>\n            Letters:\n            <input\n              autoFocus={this.props.autoFocus === true}\n              defaultValue=\"tla\"\n              type=\"text\"\n              ref={this.lettersInput} />\n          </label>\n          <label>\n            RelatedTo:\n            <input\n              defaultValue=\"finance\"\n              type=\"text\"\n              ref={this.relatedToInput} />\n          </label>\n          <label>\n            Limit:\n            <input\n              defaultValue={DEFAULT_LIMIT}\n              type=\"text\"\n              ref={this.limitInput} />\n          </label>\n          <input type=\"submit\" value=\"Submit\" />\n        </form>\n        {this.renderQueryResults()}\n      </div>\n    );\n  }\n}","import React from \"react\";\nimport { DataMuseProxy, DataMuseQuery, DataMuseQueryResult, DataMuseQueryResultItem, QUERY_TYPE } from \"../dataMuseProxy\";\n\nexport interface ClueIdea {\n  name: string;\n  ideate: (word: string) => Promise<React.ReactNode>;\n}\n\n// PROTOTYPE WITH LINKS for each \"helper\" component then I can use the api. but links are super easy.\n// Accept a whole bunch of clues at once and batch process\n// Wordplays.com api\n// datamuse for prefixes, suffixes, infixes\n// anagrams\n// rhymezone phrase search\n// rel_jja/jjb or whatever other query params I can use to simulate phrase search\n// the hoponym datamuse query: this is a type of this.\n// definition\n// splitting into multiple words?\n// link to the relevent pages, e.g. wordplays & anagrams site, when relevent\n// backwards?\n// ideate parallelize & async\n\n// makeLinkHelper() function?\n\n// datamuse\n// sp prefix suffix infix\n// synonym\n  // LEFT_CONTEXT = 'lc',\n  // RIGHT_CONTEXT = 'rc',\n// lc & rc vs bga & bgb? pick one set or both\n// definition via metadata flags\n\n// hypernm & hopoynm for clues that say \"... for two\" and \"a type of...\"\n\nconst wordplays: ClueIdea = {\n  name: 'wordplays',\n  ideate: async (word) => {\n    const link = `https://www.wordplays.com/crossword-clues/${word}`;\n    return (\n      <a href={link}>wordplays</a>\n    );\n  }\n}\n\nconst anagram: ClueIdea = {\n  name: 'anagram',\n  ideate: async (word) => {\n    const link = `http://www.anagramica.com/best/${word}`;\n    return (\n      <a href={link}>wordplays</a>\n    );\n  }\n}\n\nconst phraseSearch: ClueIdea = {\n  name: 'phraseSearch',\n  ideate: async (word) => {\n    const link = `https://rhymezone.com/r/rhyme.cgi?Word=${word}&typeofrhyme=phr`;\n    return (\n      <a href={link}>phraseSearch</a>\n    );\n  }\n}\n\nconst DATAMUSE_IDEA_QUERY_LIMIT = 10;\n\n///////////////////////////////////////////// Datamuse Ideas\n\nconst createDatamuseClueIdea = (name: string, queryParameterizer: (dmq: DataMuseQuery, word: string) => void) => {\n  const idea: ClueIdea = {\n    name,\n    ideate: async (word) => {\n      const query: DataMuseQuery = DataMuseProxy.getInstance().query();\n      queryParameterizer(query, word);\n      const nonLimitedUrl = query.getQueryUrl();\n      query.parameterize(QUERY_TYPE.MAX, DATAMUSE_IDEA_QUERY_LIMIT.toString());\n      const result = await query.execute();\n      const resultWords = result.map((item: DataMuseQueryResultItem) => {\n        return item.word;\n      });\n      const resultWordEls = resultWords.map((resultWord) => {\n        return <li key={resultWord}>{resultWord}</li>\n      });\n      let moreLink = null;\n      if (result.length === DATAMUSE_IDEA_QUERY_LIMIT) {\n        moreLink = <li><a href={nonLimitedUrl}>more</a></li>;\n      }\n      return (\n        <ul>\n          {resultWordEls}\n          {moreLink} \n        </ul>\n      );\n    }\n  }\n  return idea;\n};\n\nconst prefix: ClueIdea = createDatamuseClueIdea('prefix', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.SPELLED_LIKE, `*${word}`);\n});\n\nconst suffix: ClueIdea = createDatamuseClueIdea('suffix', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.SPELLED_LIKE, `${word}*`);\n});\n\n// datamuse\n// sp prefix suffix infix\n// synonym\n  // LEFT_CONTEXT = 'lc',\n  // RIGHT_CONTEXT = 'rc',\n// lc & rc vs bga & bgb? pick one set or both\n// definition via metadata flags\n\n// hypernm & hopoynm for clues that say \"... for two\" and \"a type of...\"\n\nconst leftContext: ClueIdea = createDatamuseClueIdea('leftContext', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.LEFT_CONTEXT, word);\n});\n\nconst rightContext: ClueIdea = createDatamuseClueIdea('rightContext', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.RIGHT_CONTEXT, word);\n});\n\nconst frequentFollowers: ClueIdea = createDatamuseClueIdea('frequentFollowers', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.FREQUENT_FOLLOWERS, word);\n});\n\nconst frequentPredecessors: ClueIdea = createDatamuseClueIdea('frequentPredecessors', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.FREQUENT_PREDECESSORS, word);\n});\n\nconst hoponyms: ClueIdea = createDatamuseClueIdea('hoponyms', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.HOPONYMS, word);\n});\n\nconst hypernyms: ClueIdea = createDatamuseClueIdea('hypernyms', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.HYPERNYMS, word);\n});\n\nconst synonyms: ClueIdea = createDatamuseClueIdea('synonyms', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.SYNONYMS_WITH, `${word}*`);\n});\n\nconst relatedTo: ClueIdea = createDatamuseClueIdea('relatedTo', (dmq, word) => {\n  dmq.parameterize(QUERY_TYPE.RELATED_TO, word);\n});\n\n\n// Uncomment and replace when making a new one.\n// const akreplace: ClueIdea = createDatamuseClueIdea('akreplace', (dmq, word) => {\n//   dmq.parameterize(QUERY_TYPE.SPELLED_LIKE, word);\n// });\n\n\nexport const CLUE_IDEAS: ClueIdea[] = [\n  wordplays,\n  anagram,\n  phraseSearch,\n  relatedTo,\n  hoponyms,\n  hypernyms,\n  frequentPredecessors,\n  frequentFollowers,\n  prefix,\n  suffix,\n\n  // Seem to be redundant with frequentPredecessors/followers\n  // rightContext,\n  // leftContext,\n\n  // Datamuse is really restrictive with synonyms, relatedTo works better\n  // synonyms,\n];\n","import React from 'react';\nimport { CLUE_IDEAS } from './ideas';\nimport { makeTable, splitAndTrim } from './util';\nimport \"./ClueHelper.css\";\n\ninterface Props {\n  autoFocus?: boolean;\n}\n\ninterface State {\n  errors: string[];\n  tableInput: any;\n}\n\n/** Gives tips for clues */\nexport default class ClueHelper extends React.PureComponent<Props, State> {\n\n  input: React.RefObject<HTMLTextAreaElement> = React.createRef();;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      errors: [],\n      tableInput: [],\n    };\n  }\n  addError = (newError: string) => {\n    this.setState((prevState) => {\n      return {\n        errors: [newError].concat(prevState.errors),\n      };\n    });\n  }\n\n\n  handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n\n    const unprocessedWords = this.input.current?.value;\n    if (!unprocessedWords) {\n      this.addError('no input');\n      return;\n    }\n\n    const words = splitAndTrim(unprocessedWords, '\\n');\n\n    const tableInput = await Promise.all(words.map(async (word) => {\n      const tableInputObject: any = {\n        word,\n      };\n      // TODO parallelize\n      for (const idea of CLUE_IDEAS) {\n        const renderableIdea = await idea.ideate(word);\n        tableInputObject[idea.name] = renderableIdea;\n      };\n      const copy = Object.assign({}, tableInputObject);\n      // return tableInputObject;\n      return copy;\n    }));\n    console.log(tableInput);\n    this.setState({ tableInput });\n  }\n\n  renderIdeas = () => {\n    return makeTable(this.state.tableInput);\n  }\n\n  render = () => {\n    return (\n      <div className=\"section\"> <h2>Clue Helper</h2>\n        <div className=\"card\">\n          <form onSubmit={this.handleSubmit}>\n            <label>\n              Words to give clues for:\n            <br />\n              <textarea\n                autoFocus={this.props.autoFocus === true}\n                placeholder=\"line separated words\"\n                ref={this.input} />\n            </label>\n            <br />\n            <input type=\"submit\" value=\"Submit\" />\n          </form>\n        </div>\n        <div className=\"card\">\n          <h3>Result</h3>\n          {this.renderIdeas()}\n        </div>\n      </div>\n    );\n  }\n}\n\n","import React from \"react\";\n\n// String.split() and trims each member. \n// Should be done for all inserts probably.\nexport const splitAndTrim = (str: string, delimiter: string): string[] => {\n  return str.split(delimiter).map((item) => { return item.trim(); })\n}\n\n// Turns arbitrary rows sql response into table. \nexport const makeTable = (rows: any[]): React.ReactNode => {\n  if (!Array.isArray(rows)) {\n    throw new Error(\"requires array\");\n  }\n  if (rows.length === 0) {\n    return (\"Empty\");\n  }\n  console.log(JSON.stringify(rows[0]))\n  console.log(rows[0])\n  const headers = Object.keys(rows[0]);\n  console.log({headers,})\n  const headerEls = headers.map((header) => {\n    return (<th key={header}>{header}</th>);\n  });\n\n  const rowEls: React.ReactNode[] = [];\n\n  rows.forEach((row) => {\n    const rowEl: React.ReactNode[] = [];\n    headers.forEach((header) => {\n      const td = <td>{row[header]}</td>\n      rowEl.push(td);\n    });\n    rowEls.push(\n      <tr>\n        {rowEl}\n      </tr>\n    );\n  });\n\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          {headerEls} \n        </tr> \n      </thead> \n      <tbody>\n        {rowEls}\n      </tbody>\n    </table>\n  );\n};","import React from \"react\";\nimport { makeGraph } from \"./algorithm\";\nimport './Home.css';\nimport InputForm from \"./InputForm\";\nimport WordDetails from \"./WordDetails\";\nimport AcronymHelper from \"./acronym/AcronymHelper\";\nimport ClueHelper from \"./cluehelper/ClueHelper\";\n\ninterface Props { }\ninterface State {\n  buildingGraph: boolean;\n  graphData: any;\n  ogWords: string[];\n}\n\nconst GRAPH_1_DIV_ID = 'cy';\n\nexport default class Home extends React.PureComponent<Props, State> {\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      buildingGraph: false,\n      graphData: 0,\n      ogWords: [],\n    };\n  }\n\n  onSubmitInput = async (words: string[]) => {\n    this.setState({ ogWords: words });\n\n    // TODO(ak): uncomment when done with WordDetails.\n    this.setState({buildingGraph: true});\n    const graphData = await makeGraph(words, GRAPH_1_DIV_ID);\n    this.setState({buildingGraph: false});\n    this.setState({\n      graphData,\n    });\n  }\n\n  // Stop abstracting stuff you're not sure how yet.\n  render = () => {\n    const wordDetailsElements = this.state.ogWords.map((ogWord: string) =>\n      <WordDetails key={ogWord} ogWord={ogWord} />);\n    return (\n      <div>\n        <ClueHelper autoFocus={true} />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <AcronymHelper autoFocus={false} />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <br /><br /><br />\n        <h2>Graph Rhyme Thing</h2>\n        <InputForm onSubmitInput={this.onSubmitInput} />\n        {this.state.buildingGraph && <p>Building Graph...</p>}\n        <div>\n          {wordDetailsElements}\n        </div>\n        <div id={GRAPH_1_DIV_ID}>\n\n        </div>\n        {JSON.stringify(this.state.graphData)}\n      </div>\n\n    );\n  }\n}","import React from 'react';\nimport { BrowserRouter, Route, Switch } from 'react-router-dom';\nimport Home from './Home';\n\ninterface Props {\n\n}\n\ninterface State {\n\n}\n\nexport default class Routes extends React.PureComponent<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n\n    };\n  }\n\n  render = () => {\n    return (\n      <BrowserRouter basename=\"PoetHelperPages\">\n        <Switch>\n          <Route path=\"/\">\n            <Home />\n          </Route>\n        </Switch>\n      </BrowserRouter>\n    );\n  }\n}\n\n","import React from 'react';\nimport Routes from './Routes';\n\ninterface Props {\n\n}\n\ninterface State {\n\n}\n\nexport default class App extends React.PureComponent<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n\n    };\n  }\n\n  render = () => {\n    return (\n      <Routes />\n    );\n  }\n}\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}